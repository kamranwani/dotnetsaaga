## ✅ C# Learning Notes (Lecture 1 to Now)

---

### 📘 **Lecture 1: Introduction to C# and .NET**

* **C#** is an object-oriented programming language developed by Microsoft.
* It runs on the **.NET platform**, which provides runtime (CLR) and libraries (BCL/FCL).
* **.NET Core / .NET 5+** is cross-platform and modern version of .NET.
* A basic C# program is a **Console Application** with a `Main` method as the entry point.

**Example:**

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello, World!");
    }
}
```

---

### 📗 **Lecture 2: Input, Output, and Data Types**

#### 👉 **User Input / Output**

* Use `Console.WriteLine()` to output to console.
* Use `Console.ReadLine()` to read from console.
* Use `TryParse()` to convert and validate data types from string inputs.

#### 👉 **Primitive Data Types**

| Data Type | Bytes | Range                           | Example                 |
| --------- | ----- | ------------------------------- | ----------------------- |
| `byte`    | 1     | 0 to 255                        | `byte b = 10;`          |
| `sbyte`   | 1     | -128 to 127                     |                         |
| `short`   | 2     | -32,768 to 32,767               |                         |
| `ushort`  | 2     | 0 to 65,535                     |                         |
| `int`     | 4     | -2,147,483,648 to 2,147,483,647 | `int age = 25;`         |
| `uint`    | 4     | 0 to 4,294,967,295              |                         |
| `long`    | 8     | Huge Range                      |                         |
| `float`   | 4     | \~6-9 digits precision          | `float pi = 3.14f;`     |
| `double`  | 8     | \~15-17 digits precision        | `double d = 3.14159;`   |
| `decimal` | 16    | \~28-29 digits precision        | For financial data      |
| `char`    | 2     | Unicode character               | `char ch = 'A';`        |
| `bool`    | 1 bit | true or false                   | `bool isTrue = true;`   |
| `string`  | N/A   | Sequence of chars               | `string name = "John";` |

---

### 📘 **Lecture 3: `out`, `ref`, `in` Parameters & Method Definitions**

* `out`: Used to return a value from a method.

  * Value must be assigned inside the method.
* `ref`: Passes a reference, so the method can modify the original value.
* `in`: Like `ref`, but **read-only**. Value cannot be changed inside the method.

```csharp
void GetSum(int a, int b, out int sum)
{
    sum = a + b;
}

void ReadOnlyExample(in int num)
{
    Console.WriteLine(num); // can't modify num
}
```

---

### 📗 **Lecture 4: Namespaces, Classes, and Access Modifiers**

#### ✔️ **Namespaces**

* A way to organize and group related classes.

```csharp
namespace MyFirstApp
{
    class MyClass { }
}
```

#### ✔️ **Classes and Methods**

* `class` is a blueprint for objects.
* Methods can be `static` (called without object) or instance methods.

#### ✔️ **Access Modifiers**

| Modifier    | Accessible Within | Across Projects | Example                              |
| ----------- | ----------------- | --------------- | ------------------------------------ |
| `private`   | Same class        | ❌               | Default for class members            |
| `internal`  | Same project      | ❌               | Default for classes                  |
| `public`    | Everywhere        | ✅               | Needed to access from other projects |
| `protected` | Derived classes   | ❌               |                                      |

---

### 🛠️ **Lecture 5: Creating Multiple Projects and Using Classes Across Projects**

* You can create a **solution** with multiple projects.
* To **use a class from another project**, you must:

  * Make the class `public`.
  * Add a **project reference** (Right-click → Add → Project Reference).
  * Use the proper `using` statement.

```csharp
// In ProjectTwo
namespace ProjectTwo
{
    public class AreaAndPerimeter
    {
        public static float CalArea(in float l, in float w) => l * w;
        public static float CalPerimeter(in float l, in float w) => 2 * (l + w);
    }
}

// In MyFirstApp
using ProjectTwo;
float area = AreaAndPerimeter.CalArea(5, 3);
```

#### ✏️ Internal class in another project?

* `internal` classes are only accessible within the same project.
* To use in another project, make them `public`.

---

### 📄 Additional Concepts Covered

* `Main` method is the starting point of execution.
* `Console.ReadLine()` returns string. Use `TryParse()` for safe conversion.
* Value Types vs Reference Types:

  * Value types store data directly (e.g., int, float).
  * Reference types store a reference to the data (e.g., string, arrays, class).
* Multi-project solutions help modularize your code.

---


---


#### 🔹 Memory Allocation: Stack vs Heap

* **Stack:**

  * Stores value types (e.g., `int`, `bool`, etc.)
  * Stores references (addresses) of objects created on the heap
  * Has limited memory
  * Fast access (LIFO structure)
* **Heap:**

  * Stores actual objects created using `new`
  * Stores reference type data (e.g., class instances, arrays)
  * Garbage collected

**Example:**

```csharp
Employee e1 = new Employee();
Employee e2 = new Employee();
```

* `e1` and `e2` are stored on the stack (they hold addresses)
* Actual `Employee` objects are on the heap

---

### 🔹 Static vs Non-Static Members

* **Static member:**

  * Belongs to the class, not the instance
  * Shared across all objects
  * Accessed using the class name: `ClassName.StaticMember`

* **Non-static member:**

  * Unique to each object
  * Accessed via the object: `objectName.NonStaticMember`

**Example:**

```csharp
public class Emp {
    public int id = 10;         // Non-static (each object gets its own id)
    public static int count = 0; // Static (shared)

    public void Fun1() {
        Console.WriteLine(id);     // Works
        Console.WriteLine(count);  // Works (can access static from non-static)
    }

    public static void Fun2() {
        // Console.WriteLine(id); // ❌ Error: can't access non-static from static
        Console.WriteLine(count);  // ✅ Works
    }
}
```

📌 Static methods **cannot** access non-static variables because there's no object context (`this` is not available).

---

### 🔹 Recursion & Stack Overflow

* A **recursive function** calls itself
* Requires a **base case** to stop recursion
* Each recursive call goes on the **stack** → too many calls without returning = **stack overflow**

**Example:**

```csharp
int Factorial(int n) {
    if (n == 1) return 1; // base case
    return n * Factorial(n - 1); // recursive case
}
```

**Dry run for `Factorial(3)`**:

```
Factorial(3) = 3 * Factorial(2)
Factorial(2) = 2 * Factorial(1)
Factorial(1) = 1
Result = 3 * 2 * 1 = 6
```

---


-------------- July 24 ------------------

declaration and defination in functions

function overloading

2 rules 
either number of argumements must be different 
or arguemnt type must be different

compile time or tatic binding or early binding

runtime or dynamic binding or late binding

polymorphism many shapes
2 types dyanamic and static
static poly overloading
dynamic tbd...

binding.

chat gpt 



### 🔹 **Function Declaration vs Definition**

* **Declaration:**
  Just tells the compiler a function exists (in some languages, needed when the definition is later in the code).

* **Definition:**
  Includes the full function body with logic.

**Example:**

```csharp
// Declaration (in some languages)
// int Add(int a, int b);

// Definition
int Add(int a, int b) {
    return a + b;
}
```

In **C#**, declaration and definition are usually together.

---

### 🔹 **Function Overloading** (Compile-time Polymorphism)

Function overloading means creating **multiple methods with the same name** but **different parameters**.

✅ **Two Rules:**

1. **Number of arguments must differ**
2. **Or types of arguments must differ**

❌ Return type alone cannot differentiate overloaded methods.

**Example:**

```csharp
void Print(int x) { }
void Print(string x) { }     // valid (type differs)
void Print(int x, int y) { } // valid (number differs)
```

---

### 🔹 **Binding in C# (Linking Call to Code)**

* **Binding:** The process of connecting a method call to the actual method code.

---

### 🔹 **Types of Binding / Polymorphism**

#### 1. **Static / Compile-time Binding**

* Also called: **Early binding**
* Done at **compile time**
* Example: **Function Overloading**

#### 2. **Dynamic / Run-time Binding**

* Also called: **Late binding**
* Done at **runtime**
* Example: **Function Overriding** (covered later)

---

### 🔹 **Polymorphism** = Many Forms

Polymorphism allows objects or methods to **behave in different ways** based on context.

#### Two Types:

1. **Static Polymorphism** → **Method Overloading**
2. **Dynamic Polymorphism** → (To be studied: involves inheritance + overriding)

---


---------------------------------------------- JULY 25 2025 --------------------------------------------

constructor is a special func that makes our object
and is called by compiler if we don't make it ourselves
also called default constructor (made by compiler)
zero arguement constructor
default vlue of refrence type and value type 
default constructor because default value being put into it


copy constructor
thi keyword

if we write constructor there is still always copy constructor.
shallow copy
deep copy

== vs equals basic difference shalow v deep comparison 

static constructor used to give default values to static fields


static default parameterised copy 
obj and static broad view

high density heap 

---

### 🔹 **Constructors in C#**

* **Default Constructor**: Provided automatically if no constructor is defined. Initializes default values.
* **Parameterized Constructor**: Allows passing values during object creation.
* **Copy Constructor**: Creates a new object using values from an existing object.
* **Static Constructor**: Used to initialize static fields. Runs once per type before any static member is accessed.

---

### 🔹 **this Keyword**

* Refers to the current object.
* Useful to resolve naming conflicts (e.g., `this.name = name`).

---

### 🔹 **Shallow Copy vs Deep Copy**

* **Shallow Copy**: Copies references. Changes in one object may affect the other.
* **Deep Copy**: Creates independent copies of reference fields.

---

### 🔹 **== vs .Equals()**

* `==`: Compares reference (for objects) or value (for primitives).
* `.Equals()`: Can be overridden to compare values even for objects.

---

### 🔹 **Static vs Instance Members**

* **Instance Members**: Belong to an object. Accessed through object.
* **Static Members**: Belong to the class. Shared across all objects. Accessed via class name.

---

### 🔹 **Object and Memory**

* Objects are stored in **Heap memory**.
* Static fields live for the duration of the application (App Domain lifetime).
* Each object gets its own instance fields but shares static fields with others.

---

### 🔹 **High-Density Heap**

* Optimized memory area used by the .NET runtime for allocating large or many small objects.
* Improves performance by reducing memory fragmentation.
* Mainly relevant in advanced performance tuning or large-scale applications.

---

---------------------------------------------type conversion

2 types of conversion
.MaxValue
value type / convertable type
implicit conversion (auto done by compiler) and explicit conversion (cast operator)

long a=121212121212121212
int b= (int)a

non convertable type/
refrence type


only possible in parent child .
as operator better way

Object aka object class
father of all objects. inbuilt

as operator in refrence mostly

is operator is not

as typecast and is check datatype returns true false


3 types of null cehck == != , is , ?.

upcasting downcasting

------------------------------------ task 1

constructor default parametirsez copy shallow deep 
array object object employee field salary ? showsalary get total salary
developer showdata show profile hr

------------------------------------ task 1

### 📘 **Type Conversion in C#**

---

### ✅ **Two Types of Conversion:**

1. **Implicit Conversion**

   * Done **automatically** by the compiler.
   * Only between **compatible types** (e.g., smaller to larger).
   * ✅ Example:

     ```csharp
     int x = 100;
     long y = x; // implicit
     ```

2. **Explicit Conversion (Type Casting)**

   * Done **manually** using **cast operator**.
   * Risk of **data loss** or **runtime error**.
   * ✅ Example:

     ```csharp
     long a = 121212121212121212;
     int b = (int)a; // explicit cast
     ```

---

### ✅ **Value Types vs Reference Types:**

* **Value Types**: int, long, float, double, bool, etc.

  * Stored on **stack**, directly hold data.
* **Reference Types**: string, arrays, custom classes, etc.

  * Stored on **heap**, hold a reference to the data.

---

### 🧠 **Object Class:**

* `Object` (capital O) is the **base class of all types** in C#.
* Every type (value or reference) inherits from `object`.

---

### ✅ **Type Checking and Casting (Reference Types):**

* **Upcasting**: Child to Parent (safe, implicit)

  ```csharp
  Dog dog = new Dog();
  Animal a = dog; // upcasting
  ```

* **Downcasting**: Parent to Child (explicit, risky)

  ```csharp
  Animal a = new Dog();
  Dog d = (Dog)a; // downcasting
  ```

---

### ✅ **Using `as` Operator:**

* Safe way to cast reference types.
* Returns `null` if cast fails.

  ```csharp
  object obj = "hello";
  string str = obj as string; // works
  int num = obj as int;       // fails, returns null
  ```

---

### ✅ **Using `is` Operator:**

* Checks if an object **is of a specific type**.
* Returns **true/false**

  ```csharp
  if (obj is string)
  {
      Console.WriteLine("It is a string");
  }
  ```

---

### ✅ **Null Checks – 3 Ways:**

1. **Equality operators:**

   ```csharp
   if (obj != null)
   ```

2. **`is` operator:**

   ```csharp
   if (obj is not null)
   ```

3. **Null Conditional (`?.`) operator:**

   ```csharp
   Console.WriteLine(obj?.ToString());
   ```

   ------------------------------------------------------------------------------------------------

  ------------------------------------------- concepts so far --------------------------------------------
   

### ✅ C# Concepts Learned So Far

#### 🔹 Type Conversion

* **Two types**:

  * **Implicit** (automatically handled by compiler)
  * **Explicit** (manual, using cast operator)

```csharp
long a = 1234567890;
int b = (int)a; // Explicit
```

* Use `.MaxValue` to avoid data loss in explicit casting.

#### 🔹 Value vs Reference Types

* **Value types**: `int`, `float`, `double`, etc. — stored on **stack**.
* **Reference types**: `string`, `object`, arrays, class instances — stored on **heap**, variable holds reference.

#### 🔹 Object Class

* `object` is the **base class** for all types in C#.
* Every class inherits from it either directly or indirectly.

#### 🔹 Type Checking

* `is`: checks if an object is of a certain type — returns **bool**.

```csharp
if (obj is string) { }
```

* `as`: attempts to cast — returns **null** if not possible.

```csharp
string s = obj as string;
```

#### 🔹 Null Checks

* `== null`, `!= null`
* `is null`, `is not null`
* Null-coalescing operator: `??`

```csharp
int? salary = null;
int sal = salary ?? 0; // Fallback to 0 if null
```

#### 🔹 Upcasting & Downcasting

* **Upcasting**: Child → Parent (always safe)
* **Downcasting**: Parent → Child (must check type using `is` or `as`)

#### 🔹 Static vs Instance Members

* `static`: Belongs to the **class**, not to any object.
* Access via class name, not instance.

```csharp
public static int count;
```

#### 🔹 Function Overloading

* Same method name, **different number or type of parameters**

```csharp
void Print() {}
void Print(string name) {}
```

#### 🔹 Constructors

* **Default constructor**: No parameters
* **Parameterized constructor**: Accepts arguments
* **Copy constructor**: Create new object using another
* **Static constructor**: Used to initialize static data; runs once

#### 🔹 Shallow vs Deep Copy

* **Shallow**: Copies references, not actual objects — both variables point to same memory.
* **Deep**: Creates a full new object in memory.

---

-----------------------------------------------------------------------------------------------------

strings
converting string to different value type

3 ways
type.Parse
type.TryParse
Convert.
To...,Single,Double,Decimal,DateTime,Int16,Byte,Int32,Int64

boxing and unboxing

boxing is saving value type directly on heap.

-------------------------------------------------------------------------------------------------------
encapsulation 

setter n getter
setter can set one field
has no return type
setter only takes one input

get has no param has return type

best practice is to set and get with just one field
and this is the rule for setter and getter

interface functions which internally access private fields. public functions, this is encapsulation.


there is a newer way in .net known as props

tbd tom....

task make class, make fileds few, set and getter of every field.

Here are your **complete, clean notes** for today's C# lecture:

---

## 📘 C# Lecture Notes – August 4, 2025

### 🧠 Topic: String Conversion, Boxing/Unboxing, Encapsulation Practice (with Car class)

---

### 🔁 **1. String Conversion Methods**

#### ✅ `Parse()`

* Converts **string → value type**
* Throws exception if input is invalid or null

```csharp
int age = int.Parse("25"); // Works
int age = int.Parse("abc"); // ❌ throws FormatException
```

#### ✅ `TryParse()`

* Converts string → value type **safely**
* Returns `true/false` instead of throwing exception

```csharp
bool success = int.TryParse("25", out int age); // ✅ success = true, age = 25
bool fail = int.TryParse("abc", out int result); // ✅ success = false, result = 0
```

#### ✅ `Convert.ToX()`

* Can convert null/invalid safely
* Returns default value (e.g., 0 for int) on null

```csharp
int x = Convert.ToInt32("123"); // 123
int y = Convert.ToInt32(null);  // 0
int z = Convert.ToInt32("abc"); // ❌ throws FormatException
```

---

### 📦 **2. Boxing and Unboxing**

| Term         | Meaning                                                      |
| ------------ | ------------------------------------------------------------ |
| **Boxing**   | Wrapping a **value type** into an **object**, stored on heap |
| **Unboxing** | Extracting the value type back from the object               |

```csharp
int n = 10;
object obj = n;      // ✔️ Boxing

int x = (int)obj;    // ✔️ Unboxing
```

---

### 🔒 **3. Encapsulation**

* Binding fields and restricting access through **getters** and **setters**
* Use `private` fields and `public` methods

#### ✅ Setter:

* No return type
* Takes **only one input**

```csharp
public void SetBrandName(string brandName) { ... }
```

#### ✅ Getter:

* Has return type
* Takes **no input**

```csharp
public string GetBrandName() { return _BrandName; }
```

#### 🛡️ Why Encapsulation?

* Controls what gets read or modified
* Prevents direct external access to class data

---

### 🚗 **4. Practice Class: `Cars`**

#### Fields:

```csharp
private string _BrandName;
private string _CarModel;
private string _CarName;
private int _Year;
private decimal _Price;
public static int _NumberOfUnits;
```

#### Constructors:

* Default constructor
* Parameterized constructor
* Copy constructor
* Static constructor

#### Methods:

* Setters & Getters for each field
* `ShowCarData()` to print car info
* `Main()` demonstrates:

  * Setting data
  * Using all 3 constructors
  * Copy vs clone
  * `_NumberOfUnits` tracking

---

### 🧪 Example Decimal Use

```csharp
car.SetPrice(104000.11m); // ✅ m indicates decimal
```
-----------------------------------------------------------------------------------------------------------

property aka prop get set

auto implemented property


----------------------------------------------------------------------------------------------------------
about namespace
fully qualified name
aliasing
system root or base namespace

Bank Account
prop act no name address contact num email parentage bal

some manual mostly add validation some autoimport

deposit (Add amt) withdrwal(sub amt) balance
1000 bal min


curent saving both account

------------------------------------------------------------------------------------------------------------------------------
Presentation Layer /UI layer

seperation 
exe(i/o) dll(no i/o)

application layer/ business layer 
write logic n working here

model layer entity layer domain layer 3-layer

data layer/physical layer
where data is saved typical eg, database N-layer

layer = tier onion architecture , clean arcitecture latest, cqis





























